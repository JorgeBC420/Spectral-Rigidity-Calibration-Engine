"""
PROTOCOLO DE RIGIDEZ ESPECTRAL
===============================

Módulo de análisis metrológico para estudiar la estructura dinámica de los ceros
de Riemann mediante comparación con benchmarks (Uniforme, GUE) y análisis del
espectro del Jacobiano.

ESTRUCTURA:
-----------
1. Generación de sistemas de benchmark (distribuciones de control)
2. Cálculo eficiente del Jacobiano (Neg-Hessiano del log-gas)
3. Análisis espectral y caracterización del modo más blando
4. Protocolo experimental de escalamiento con N
5. Visualización comparativa e interpretación

ADVERTENCIA EPISTEMOLÓGICA:
----------------------------
Este análisis NO busca "inestabilidades" (el sistema es por definición gradiente).
Busca RIGIDEZ ESPECTRAL: medir si el gap espectral del sistema de Riemann se
escala de forma diferente a otros sistemas con repulsión logarítmica, lo que
revelaría estructura adicional no capturada en el truncamiento.
"""

import numpy as np
import scipy.linalg as la
from numba import jit, prange
import matplotlib.pyplot as plt
from typing import Tuple, Dict, List, Optional
import mpmath as mp
import warnings
import logging

# ============================================================================
# CONFIGURACIÓN DE LOGGING
# ============================================================================

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Suprimir advertencias de convergencia leves
warnings.filterwarnings('ignore', category=np.ComplexWarning)
warnings.filterwarnings('ignore', message='.*invalid value.*')


# ============================================================================
# GENERACIÓN DE BENCHMARKS
# ============================================================================

def generar_uniforme(N: int, soporte: Tuple[float, float] = (0, N)) -> np.ndarray:
    """
    Red cristalina perfecta (máxima rigidez posible).
    
    Una partición uniforme representa el límite de máxima "fijación".
    Sirve como control de la hipótesis "es solo un efecto de repulsión genérica".
    """
    return np.linspace(soporte[0], soporte[1], N)


def generar_gue_normalizado(N: int, escala: float = 1.0) -> np.ndarray:
    """
    Espectro de GUE (Gaussian Unitary Ensemble).
    
    Mediante:
    1. Construcción de matriz Hermítica aleatoria
    2. Diagonalización para extraer autovalores
    3. Re-escalado para compatibilidad de rango
    
    Los autovalores del GUE siguen la distribución de Wigner (semicírculo).
    """
    # Matriz aleatoria compleja
    A = np.random.randn(N, N) + 1j * np.random.randn(N, N)
    # Hermitianización
    H = (A + A.conj().T) / (2 * np.sqrt(N))
    # Espectro
    evals = la.eigvalsh(H)
    # Re-escalado para tener soporte similar al de Riemann
    evals_escalado = escala * (evals - np.mean(evals)) / np.std(evals) + N/2
    return np.sort(evals_escalado)


def generar_poisson(N: int, soporte: Tuple[float, float] = (0, N)) -> np.ndarray:
    """
    Proceso de Poisson puro (mínima rigidez).
    
    Los "ceros" son puntos de un proceso de Poisson homogéneo.
    Completamente sin correlaciones (benchmark de comparación).
    """
    a, b = soporte
    return np.sort(np.random.uniform(a, b, N))


# ============================================================================
# CÁLCULOS ESPECTRALES (JIT)
# ============================================================================

@jit(nopython=True, fastmath=True)
def unfolding_riemann(gamma: np.ndarray) -> np.ndarray:
    """
    Transformación diferencial acumulativa para normalizar la densidad.
    
    Usa la fórmula de Riemann-von Mangoldt:
    N(T) = (T/2π) * log(T/2πe) + O(1)
    
    Esto convierte ceros con densidad variable a densidad local ≈ 1.
    """
    return (gamma / (2 * np.pi)) * (np.log(gamma / (2 * np.pi)) - 1.0)


@jit(nopython=True, parallel=True)
def calcular_jacobiano_kernel(gamma: np.ndarray) -> np.ndarray:
    """
    Jacobiano de la dinámica: J = -Hessiano(E_log_gas).
    
    Elementos:
    J_kl = 2 / (gamma_k - gamma_l)^2   para k ≠ l
    J_kk = - Σ_{j≠k} J_kj              (suma de fila)
    
    Propiedades:
    - Matriz simétrica (real)
    - Semidefinida negativa (J ≤ 0)
    - Autovalor 0 corresponde a traslación global
    - Primer autovalor no nulo: gap espectral (modo más blando)
    """
    N = len(gamma)
    J = np.zeros((N, N))
    
    # Elementos fuera de la diagonal
    for k in prange(N):
        for l in range(k + 1, N):
            diff_sq = (gamma[k] - gamma[l]) ** 2
            val = 2.0 / diff_sq
            J[k, l] = val
            J[l, k] = val
    
    # Diagonal (suma de filas)
    for k in range(N):
        J[k, k] = -np.sum(J[k, :])
    
    return J


@jit(nopython=True, fastmath=True)
def energia_log_gas(gamma: np.ndarray) -> float:
    """
    Energía Hamiltoniana del gas logarítmico.
    
    E = -Σ_{i<j} log|γ_i - γ_j|
    
    Mide la "compresión" del sistema. Valores altos = ceros cercanos.
    """
    N = len(gamma)
    E = 0.0
    
    for i in range(N):
        for j in range(i + 1, N):
            diff = gamma[i] - gamma[j]
            E -= np.log(np.abs(diff))
    
    return E


# ============================================================================
# ANÁLISIS ESPECTRAL
# ============================================================================

def analizar_espectro_completo(gamma: np.ndarray, sistema_label: str = "Anónimo") -> Dict:
    """
    Ejecución completa del análisis espectral de un sistema de partículas.
    
    Retorna diccionario con:
    - gap: Brecha espectral |λ_1| (modo más blando)
    - lambda_0: Autovalor 0 (traslación, debe ser ~0)
    - evals_sorted: Array completo de autovalores
    - v1: Vector propio asociado al modo blando
    - energia: Energía Hamiltoniana del sistema
    - indice_condicion: Número de condición de J (estabilidad numérica)
    """
    N = len(gamma)
    
    # Unfolding diferencial
    gamma_u = unfolding_riemann(gamma)
    
    # Jacobiano
    J = calcular_jacobiano_kernel(gamma_u)
    
    # Espectro (eigh es óptimo para simétricas)
    evals, evecs = la.eigh(J)
    
    # Ordenar de mayor a menor (recordar: J ≤ 0, así que los mayores están cerca de 0)
    idx_ordenado = np.argsort(evals)[::-1]
    evals_sorted = evals[idx_ordenado]
    evecs_reordenados = evecs[:, idx_ordenado]
    
    # Autovalores de interés
    lambda_0 = evals_sorted[0]  # Debe ser ~0 (traslación)
    lambda_1 = evals_sorted[1]  # Primer modo no nulo
    gap = np.abs(lambda_1)
    
    v1 = evecs_reordenados[:, 1]  # Vector propio del modo blando
    
    # Energía
    energia = energia_log_gas(gamma_u)
    
    # Condición numérica
    cond_J = np.linalg.cond(J)
    
    return {
        'N': N,
        'sistema': sistema_label,
        'gap': gap,
        'lambda_0': lambda_0,
        'lambda_1': lambda_1,
        'evals': evals_sorted,
        'v_modo_blando': v1,
        'energia': energia,
        'cond_J': cond_J,
        'gamma_original': gamma,
        'gamma_unfolded': gamma_u,
        'jacobiano': J
    }


def analizar_modo_blando(resultado: Dict) -> Dict:
    """
    Caracterización del vector propio del modo más blando.
    
    Analiza si está:
    - Localizado en bordes (artefacto)
    - Distribuido uniformemente (modo global genuino)
    - Periódico/sinusoidal (elasticidad continua)
    """
    v1 = resultado['v_modo_blando']
    N = len(v1)
    
    # Normalización
    v1_norm = v1 / np.max(np.abs(v1))
    
    # Partición en terciles
    tercio_inicio = np.mean(np.abs(v1_norm[:N//3]))
    tercio_medio = np.mean(np.abs(v1_norm[N//3:2*N//3]))
    tercio_final = np.mean(np.abs(v1_norm[2*N//3:]))
    
    # Índice de localización: ratio entre extremos y centro
    localizacion = (tercio_inicio + tercio_final) / (2 * tercio_medio + 1e-10)
    
    # Periodicidad: correlación con sin(π*i/N)
    x = np.arange(N)
    sinusoide = np.sin(np.pi * x / N)
    correlacion_sin = np.abs(np.corrcoef(v1_norm, sinusoide)[0, 1])
    
    # Energía en bordes vs centro
    energia_borde = (np.sum(v1_norm[:5]**2) + np.sum(v1_norm[-5:]**2))
    energia_centro = np.sum(v1_norm[5:-5]**2)
    ratio_borde = energia_borde / (energia_centro + 1e-10)
    
    return {
        'localizacion_index': localizacion,
        'correlacion_sinusoidal': correlacion_sin,
        'ratio_energia_borde': ratio_borde,
        'interpretacion': clasificar_modo_blando(localizacion, correlacion_sin, ratio_borde)
    }


def clasificar_modo_blando(loc: float, corr_sin: float, ratio_borde: float) -> str:
    """Clasificación heurística del carácter del modo blando."""
    
    if ratio_borde > 0.5:
        return "LOCALIZADO EN BORDES (artefacto de truncamiento)"
    elif corr_sin > 0.8:
        return "SINUSOIDAL (elasticidad continua auténtica)"
    elif loc < 0.3:
        return "MODO GLOBAL (ondulación colectiva del bulto)"
    else:
        return "ESTRUCTURA COMPLEJA (mezcla de modos)"


# ============================================================================
# PROTOCOLO DE ESCALAMIENTO
# ============================================================================

def ejecutar_protocolo_escalamiento(
    N_values: List[int],
    cache_obtener=None,
    num_realizaciones_gue: int = 5
) -> Dict:
    """
    Ejecución del protocolo completo de scalabilidad.
    
    Parámetros:
    -----------
    N_values : Lista de tamaños N a analizar
    cache_obtener : Función que retorna ceros reales (p.ej. CACHE.obtener)
    num_realizaciones_gue : Número de muestras aleatorias GUE para promediar
    
    Retorna:
    --------
    Diccionario con resultados de los tres sistemas.
    """
    
    print("\n" + "="*80)
    print("PROTOCOLO DE RIGIDEZ ESPECTRAL (Escalamiento con N)")
    print("="*80)
    
    resultados = {
        'riemann': [],
        'uniforme': [],
        'gue': [],
        'poisson': []
    }
    
    analisis_modo_blando = {
        'riemann': [],
        'uniforme': [],
        'gue': [],
        'poisson': []
    }
    
    for N in N_values:
        print(f"\n[N = {N}]")
        
        # === RIEMANN ===
        if cache_obtener is not None:
            gamma_riemann = cache_obtener(N)
            resultado_r = analizar_espectro_completo(gamma_riemann, "Riemann")
            resultados['riemann'].append(resultado_r)
            
            modo_r = analizar_modo_blando(resultado_r)
            analisis_modo_blando['riemann'].append(modo_r)
            
            print(f"  Riemann:  gap = {resultado_r['gap']:.4e}, "
                  f"cond = {resultado_r['cond_J']:.2e}, "
                  f"E = {resultado_r['energia']:.4e}")
        
        # === UNIFORME ===
        gamma_uniforme = generar_uniforme(N)
        resultado_u = analizar_espectro_completo(gamma_uniforme, "Uniforme")
        resultados['uniforme'].append(resultado_u)
        
        modo_u = analizar_modo_blando(resultado_u)
        analisis_modo_blando['uniforme'].append(modo_u)
        
        print(f"  Uniforme: gap = {resultado_u['gap']:.4e}, "
              f"cond = {resultado_u['cond_J']:.2e}")
        
        # === GUE (múltiples realizaciones) ===
        gaps_gue = []
        for r in range(num_realizaciones_gue):
            gamma_gue = generar_gue_normalizado(N)
            resultado_g = analizar_espectro_completo(gamma_gue, f"GUE (r={r})")
            gaps_gue.append(resultado_g['gap'])
        
        gap_gue_promedio = np.mean(gaps_gue)
        resultado_gue_promedio = {
            'N': N,
            'gap': gap_gue_promedio,
            'gap_std': np.std(gaps_gue)
        }
        resultados['gue'].append(resultado_gue_promedio)
        
        print(f"  GUE:      gap = {gap_gue_promedio:.4e} ± {np.std(gaps_gue):.4e} "
              f"({num_realizaciones_gue} realizaciones)")
        
        # === POISSON ===
        gamma_poisson = generar_poisson(N)
        resultado_p = analizar_espectro_completo(gamma_poisson, "Poisson")
        resultados['poisson'].append(resultado_p)
        
        modo_p = analizar_modo_blando(resultado_p)
        analisis_modo_blando['poisson'].append(modo_p)
        
        print(f"  Poisson:  gap = {resultado_p['gap']:.4e}, "
              f"cond = {resultado_p['cond_J']:.2e}")
    
    return {
        'espectra': resultados,
        'modos_blandos': analisis_modo_blando,
        'N_values': N_values
    }


# ============================================================================
# ANÁLISIS DE ESCALAMIENTO Y AJUSTE CRÍTICO
# ============================================================================

def ajustar_exponente_critico(N_values: np.ndarray, gaps: np.ndarray) -> Dict:
    """
    Ajusta Δλ ∝ N^(-α) en escala log-log.
    
    Retorna:
    --------
    - exponente: α (pendiente en log-log)
    - prefactor: C tal que Δλ ≈ C * N^(-α)
    - R2: Bondad del ajuste
    """
    
    # Filtrar valores válidos
    mask = (gaps > 0) & (np.isfinite(gaps))
    N_valid = N_values[mask]
    gaps_valid = gaps[mask]
    
    if len(N_valid) < 2:
        return {'error': 'Datos insuficientes'}
    
    # Ajuste log-log
    log_N = np.log(N_valid)
    log_gap = np.log(gaps_valid)
    
    # Regresión lineal
    p = np.polyfit(log_N, log_gap, 1)
    alpha = -p[0]  # Pendiente negativa = exponente positivo
    log_C = p[1]
    C = np.exp(log_C)
    
    # Bondad
    y_pred = p[0] * log_N + p[1]
    SS_res = np.sum((log_gap - y_pred)**2)
    SS_tot = np.sum((log_gap - np.mean(log_gap))**2)
    R2 = 1 - (SS_res / SS_tot)
    
    return {
        'exponente': alpha,
        'prefactor': C,
        'R2': R2,
        'polinomio': p
    }


# ============================================================================
# VISUALIZACIÓN
# ============================================================================

def visualizar_protocolo_completo(datos: Dict):
    """
    Suite de gráficos para interpretación del protocolo.
    """
    
    resultados = datos['espectra']
    modos = datos['modos_blandos']
    N_values = np.array(datos['N_values'])
    
    fig = plt.figure(figsize=(20, 12))
    gs = fig.add_gridspec(3, 3, hspace=0.35, wspace=0.3)
    
    # ========== PANEL 1: Gap vs N (Escala Lineal) ==========
    ax1 = fig.add_subplot(gs[0, 0])
    
    for sistema in ['riemann', 'uniforme', 'gue', 'poisson']:
        if sistema in resultados and len(resultados[sistema]) > 0:
            if sistema == 'gue':
                gaps = [r['gap'] for r in resultados[sistema]]
            else:
                gaps = [r['gap'] for r in resultados[sistema]]
            
            ax1.plot(N_values, gaps, 'o-', linewidth=2, markersize=6,
                    label=sistema.capitalize())
    
    ax1.set_xlabel('N', fontsize=11, fontweight='bold')
    ax1.set_ylabel('Gap Espectral Δλ', fontsize=11, fontweight='bold')
    ax1.set_title('Brecha Espectral vs N (Lineal)', fontsize=12, fontweight='bold')
    ax1.legend(fontsize=10)
    ax1.grid(alpha=0.3)
    
    # ========== PANEL 2: Gap vs N (Escala Log-Log) ==========
    ax2 = fig.add_subplot(gs[0, 1])
    
    for sistema in ['riemann', 'uniforme', 'gue', 'poisson']:
        if sistema in resultados and len(resultados[sistema]) > 0:
            if sistema == 'gue':
                gaps = np.array([r['gap'] for r in resultados[sistema]])
            else:
                gaps = np.array([r['gap'] for r in resultados[sistema]])
            
            ax2.loglog(N_values, gaps, 'o-', linewidth=2, markersize=6,
                      label=sistema.capitalize())
            
            # Ajuste crítico
            ajuste = ajustar_exponente_critico(N_values, gaps)
            if 'exponente' in ajuste:
                N_fit = np.linspace(N_values[0], N_values[-1], 100)
                gap_fit = ajuste['prefactor'] * N_fit**(-ajuste['exponente'])
                ax2.loglog(N_fit, gap_fit, '--', alpha=0.5, linewidth=1.5)
                
                print(f"\n[{sistema.upper()}] Escalamiento: Δλ ~ N^(-{ajuste['exponente']:.3f}), R² = {ajuste['R2']:.4f}")
    
    ax2.set_xlabel('N', fontsize=11, fontweight='bold')
    ax2.set_ylabel('Δλ', fontsize=11, fontweight='bold')
    ax2.set_title('Escalamiento Crítico (Log-Log)', fontsize=12, fontweight='bold')
    ax2.legend(fontsize=10)
    ax2.grid(alpha=0.3, which='both')
    
    # ========== PANEL 3: Energía vs N ==========
    ax3 = fig.add_subplot(gs[0, 2])
    
    for sistema in ['riemann', 'uniforme', 'poisson']:
        if sistema in resultados and len(resultados[sistema]) > 0:
            energias = [r['energia'] for r in resultados[sistema]]
            ax3.plot(N_values, energias, 'o-', linewidth=2, markersize=6,
                    label=sistema.capitalize())
    
    ax3.set_xlabel('N', fontsize=11, fontweight='bold')
    ax3.set_ylabel('Energía Log-Gas E', fontsize=11, fontweight='bold')
    ax3.set_title('Energía del Sistema vs N', fontsize=12, fontweight='bold')
    ax3.legend(fontsize=10)
    ax3.grid(alpha=0.3)
    
    # ========== PANEL 4: Modo Blando (Riemann, N más grande) ==========
    if 'riemann' in resultados and len(resultados['riemann']) > 0:
        ax4 = fig.add_subplot(gs[1, 0])
        
        idx_N_max = len(resultados['riemann']) - 1
        v1 = resultados['riemann'][idx_N_max]['v_modo_blando']
        N_actual = resultados['riemann'][idx_N_max]['N']
        
        v1_norm = v1 / np.max(np.abs(v1))
        x = np.arange(len(v1_norm))
        
        ax4.plot(x / N_actual, v1_norm, 'o-', linewidth=1.5, markersize=4,
                color='#2E86AB', label='v₁ observado')
        
        # Overlay sinusoidal
        sinusoide = np.sin(np.pi * x / N_actual)
        ax4.plot(x / N_actual, sinusoide, '--', linewidth=2, alpha=0.6,
                color='#F18F01', label='sin(πi/N)')
        
        ax4.set_xlabel('Posición (i/N)', fontsize=11, fontweight='bold')
        ax4.set_ylabel('v₁(i) normalizado', fontsize=11, fontweight='bold')
        ax4.set_title(f'Modo Blando (Riemann, N={N_actual})', fontsize=12, fontweight='bold')
        ax4.legend(fontsize=10)
        ax4.grid(alpha=0.3)
    
    # ========== PANEL 5: Modo Blando (Uniforme) ==========
    if 'uniforme' in resultados and len(resultados['uniforme']) > 0:
        ax5 = fig.add_subplot(gs[1, 1])
        
        idx_N_max = len(resultados['uniforme']) - 1
        v1 = resultados['uniforme'][idx_N_max]['v_modo_blando']
        N_actual = resultados['uniforme'][idx_N_max]['N']
        
        v1_norm = v1 / np.max(np.abs(v1))
        x = np.arange(len(v1_norm))
        
        ax5.plot(x / N_actual, v1_norm, 'o-', linewidth=1.5, markersize=4,
                color='#A23B72', label='v₁ observado')
        
        sinusoide = np.sin(np.pi * x / N_actual)
        ax5.plot(x / N_actual, sinusoide, '--', linewidth=2, alpha=0.6,
                color='#F18F01', label='sin(πi/N)')
        
        ax5.set_xlabel('Posición (i/N)', fontsize=11, fontweight='bold')
        ax5.set_ylabel('v₁(i) normalizado', fontsize=11, fontweight='bold')
        ax5.set_title(f'Modo Blando (Uniforme, N={N_actual})', fontsize=12, fontweight='bold')
        ax5.legend(fontsize=10)
        ax5.grid(alpha=0.3)
    
    # ========== PANEL 6: Modo Blando (GUE) ==========
    if 'gue' in resultados and len(resultados['gue']) > 0:
        ax6 = fig.add_subplot(gs[1, 2])
        
        # Para GUE, recalculamos con una realización
        N_test = N_values[-1]
        gamma_gue = generar_gue_normalizado(N_test)
        resultado_gue = analizar_espectro_completo(gamma_gue, "GUE")
        
        v1 = resultado_gue['v_modo_blando']
        N_actual = N_test
        
        v1_norm = v1 / np.max(np.abs(v1))
        x = np.arange(len(v1_norm))
        
        ax6.plot(x / N_actual, v1_norm, 'o-', linewidth=1.5, markersize=4,
                color='#06A77D', label='v₁ observado')
        
        sinusoide = np.sin(np.pi * x / N_actual)
        ax6.plot(x / N_actual, sinusoide, '--', linewidth=2, alpha=0.6,
                color='#F18F01', label='sin(πi/N)')
        
        ax6.set_xlabel('Posición (i/N)', fontsize=11, fontweight='bold')
        ax6.set_ylabel('v₁(i) normalizado', fontsize=11, fontweight='bold')
        ax6.set_title(f'Modo Blando (GUE, N={N_actual})', fontsize=12, fontweight='bold')
        ax6.legend(fontsize=10)
        ax6.grid(alpha=0.3)
    
    # ========== PANEL 7: Índice de Localización ==========
    ax7 = fig.add_subplot(gs[2, 0])
    
    for sistema in ['riemann', 'uniforme', 'poisson']:
        if sistema in modos and len(modos[sistema]) > 0:
            localizaciones = [m['localizacion_index'] for m in modos[sistema]]
            ax7.plot(N_values, localizaciones, 'o-', linewidth=2, markersize=6,
                    label=sistema.capitalize())
    
    ax7.axhline(0.3, color='red', linestyle='--', linewidth=1.5, alpha=0.5,
               label='Umbral global/borde')
    ax7.axhline(0.5, color='orange', linestyle='--', linewidth=1.5, alpha=0.5,
               label='Umbral crítico')
    
    ax7.set_xlabel('N', fontsize=11, fontweight='bold')
    ax7.set_ylabel('Índice de Localización', fontsize=11, fontweight='bold')
    ax7.set_title('Carácter del Modo Blando (Localización)', fontsize=12, fontweight='bold')
    ax7.legend(fontsize=9)
    ax7.grid(alpha=0.3)
    
    # ========== PANEL 8: Correlación Sinusoidal ==========
    ax8 = fig.add_subplot(gs[2, 1])
    
    for sistema in ['riemann', 'uniforme', 'poisson']:
        if sistema in modos and len(modos[sistema]) > 0:
            correlaciones = [m['correlacion_sinusoidal'] for m in modos[sistema]]
            ax8.plot(N_values, correlaciones, 'o-', linewidth=2, markersize=6,
                    label=sistema.capitalize())
    
    ax8.axhline(0.8, color='green', linestyle='--', linewidth=1.5, alpha=0.5,
               label='Umbral sinusoidal')
    
    ax8.set_xlabel('N', fontsize=11, fontweight='bold')
    ax8.set_ylabel('Correlación con sin(πi/N)', fontsize=11, fontweight='bold')
    ax8.set_title('Periodicidad del Modo Blando', fontsize=12, fontweight='bold')
    ax8.legend(fontsize=9)
    ax8.set_ylim([-0.1, 1.1])
    ax8.grid(alpha=0.3)
    
    # ========== PANEL 9: Resumen Comparativo ==========
    ax9 = fig.add_subplot(gs[2, 2])
    ax9.axis('off')
    
    resumen_texto = """
╔════════════════════════════════════════╗
║    DIAGNÓSTICO DE RIGIDEZ ESPECTRAL    ║
╠════════════════════════════════════════╣
║                                        ║
║  INTERPRETACIÓN DE RESULTADOS          ║
║  ────────────────────────────────────  ║
║                                        ║
║  Exponente α (Gap ~ N^(-α)):           ║
║  • α = 2:   Hidrodinámica universal    ║
║  • α < 2:   Mayor rigidez (especial)   ║
║  • α > 2:   Menor rigidez (caótico)    ║
║                                        ║
║  Modo Blando:                          ║
║  • Sinusoidal: Elasticidad continua    ║
║  • Global: Fluctuación colectiva       ║
║  • Localizado: Artefacto de borde      ║
║                                        ║
║  Energía:                              ║
║  ↑ rápida: Ceros compresionándose      ║
║  ↓ lenta:  Equilibrio estadístico      ║
║                                        ║
╚════════════════════════════════════════╝
"""
    
    ax9.text(0.05, 0.5, resumen_texto, fontsize=9.5, verticalalignment='center',
            fontfamily='monospace',
            bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.3))
    
    plt.suptitle(
        'PROTOCOLO DE RIGIDEZ ESPECTRAL: Comparación Riemann vs Benchmarks\n'
        '(Jacobiano del Log-Gas Truncado)',
        fontsize=14, fontweight='bold'
    )
    
    plt.savefig('rigidez_espectral_protocolo.png', dpi=200, bbox_inches='tight')
    print("\n✓ Gráfico guardado: rigidez_espectral_protocolo.png")
    
    plt.show()


# ============================================================================
# INTERFAZ PRINCIPAL
# ============================================================================

def ejecutar_analisis_completo(
    cache_obtener,
    N_values: List[int] = None,
    verbose: bool = True
):
    """
    Ejecución de cabo a rabo del protocolo de rigidez espectral.
    
    Parámetros:
    -----------
    cache_obtener : Función que retorna array de ceros (p.ej. CACHE.obtener)
    N_values : Lista de tamaños N (por defecto [100, 200, 500, 1000, 2000])
    verbose : Imprime resultados
    
    Retorna:
    --------
    Diccionario con todos los datos y resultados del análisis.
    """
    
    if N_values is None:
        N_values = [100, 200, 500, 1000, 2000]
    
    # Ejecutar protocolo
    datos = ejecutar_protocolo_escalamiento(N_values, cache_obtener=cache_obtener)
    
    # Visualizar
    visualizar_protocolo_completo(datos)
    
    return datos


if __name__ == "__main__":
    print("""
    Módulo de Rigidez Espectral
    ============================
    
    Use este módulo integrándolo en solucionador_reimann.py:
    
    from rigidez_espectral import ejecutar_analisis_completo
    
    datos = ejecutar_analisis_completo(CACHE.obtener)
    """)
